<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ö–æ–ª–µ—Å–æ –∂–∏–∑–Ω–µ–Ω–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #003B48;
            --accent: #C31532;
            --secondary: #495761;
            --background: #FFFFFF;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--background);
            color: var(--primary);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 700px;
            margin: 0 auto;
        }

        h1 {
            text-align: center;
            color: var(--primary);
            margin-bottom: 10px;
            font-size: 2rem;
        }

        .subtitle {
            text-align: center;
            color: var(--secondary);
            margin-bottom: 20px;
            font-size: 0.95rem;
        }

        .chart-container {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
            touch-action: none;
            overflow: visible;
        }

        .chart-wrapper {
            display: inline-flex;
            justify-content: center;
            align-items: center;
            background: #ffffff;
            border: 1px solid #e2e8f0;
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 12px 30px rgba(0, 59, 72, 0.08);
            overflow: visible;
        }

        #radarChart {
            max-width: 100%;
            height: auto;
            cursor: default;
            overflow: visible;
        }

        .data-point {
            cursor: grab;
            transition: r 0.15s ease;
        }

        .data-point:hover {
            r: 12;
        }

        .data-point.dragging {
            cursor: grabbing;
            r: 14;
        }

        .buttons-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            flex-wrap: wrap;
            margin-bottom: 20px;
        }

        .btn {
            padding: 14px 36px;
            font-size: 1rem;
            font-weight: 600;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-reset {
            background: var(--secondary);
            color: white;
        }

        .btn-reset:hover {
            background: #3d4a52;
            transform: translateY(-2px);
        }

        .btn-save {
            background: var(--accent);
            color: white;
        }

        .btn-save:hover {
            background: #a01228;
            transform: translateY(-2px);
        }

        /* Balance indicator */
        .balance-indicator {
            text-align: center;
            margin-bottom: 20px;
            padding: 15px;
            background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%);
            border-radius: 12px;
        }

        .balance-label {
            font-size: 0.9rem;
            color: var(--secondary);
            margin-bottom: 5px;
        }

        .balance-score {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--primary);
        }

        .balance-score span {
            font-size: 1rem;
            color: var(--secondary);
        }

        /* Modal Styles */
        .modal-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 59, 72, 0.7);
            justify-content: center;
            align-items: center;
            z-index: 1000;
            animation: fadeIn 0.3s ease;
        }

        .modal-overlay.active {
            display: flex;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal {
            background: white;
            padding: 40px;
            border-radius: 16px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideUp 0.3s ease;
        }

        @keyframes slideUp {
            from { 
                opacity: 0;
                transform: translateY(30px);
            }
            to { 
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-icon {
            width: 70px;
            height: 70px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            margin: 0 auto 20px;
        }

        .modal-icon svg {
            width: 36px;
            height: 36px;
            fill: white;
        }

        .modal h2 {
            color: var(--primary);
            margin-bottom: 15px;
            font-size: 1.5rem;
        }

        .modal p {
            color: var(--secondary);
            margin-bottom: 25px;
            line-height: 1.6;
        }

        .modal-stats {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 25px;
        }

        .modal-stats p {
            margin: 0;
            font-size: 0.95rem;
        }

        .modal-stats strong {
            color: var(--accent);
        }

        .btn-close {
            background: var(--primary);
            color: white;
            padding: 12px 40px;
        }

        .btn-close:hover {
            background: #002a33;
        }

        @media (max-width: 600px) {
            h1 {
                font-size: 1.5rem;
            }

            .btn {
                width: 100%;
            }

            .buttons-container {
                flex-direction: column;
                padding: 0 10px;
            }

            .chart-wrapper {
                padding: 10px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéØ –ö–æ–ª–µ—Å–æ –ñ–∏–∑–Ω–µ–Ω–Ω–æ–≥–æ –ë–∞–ª–∞–Ω—Å–∞</h1>
        <p class="subtitle">–ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–π—Ç–µ —Ç–æ—á–∫–∏ –Ω–∞ –≥—Ä–∞—Ñ–∏–∫–µ –¥–ª—è –æ—Ü–µ–Ω–∫–∏ —Å—Ñ–µ—Ä –∂–∏–∑–Ω–∏</p>

        <div class="chart-container">
            <div class="chart-wrapper" id="chartWrapper">
                <svg id="radarChart" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 600 600" width="520" height="520"></svg>
            </div>
        </div>

        <div class="balance-indicator">
            <div class="balance-label">–û–±—â–∏–π –±–∞–ª–∞–Ω—Å</div>
            <div class="balance-score"><span id="avgScore">5.0</span> <span>/ 10</span></div>
        </div>

        <div class="buttons-container">
            <button class="btn btn-reset" onclick="resetAll()">üîÑ –°–±—Ä–æ—Å–∏—Ç—å</button>
            <button class="btn btn-save" onclick="saveResult()">üíæ –°–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç</button>
        </div>
    </div>

    <!-- Modal -->
    <div class="modal-overlay" id="modalOverlay">
        <div class="modal">
            <div class="modal-icon">
                <svg viewBox="0 0 24 24"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>
            </div>
            <h2>–†–µ–∑—É–ª—å—Ç–∞—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω!</h2>
            <p>–í–∞—à–∞ –æ—Ü–µ–Ω–∫–∞ –∂–∏–∑–Ω–µ–Ω–Ω–æ–≥–æ –±–∞–ª–∞–Ω—Å–∞ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω–∞. –°–∫—Ä–∏–Ω—à–æ—Ç –≥—Ä–∞—Ñ–∏–∫–∞ –∑–∞–≥—Ä—É–∂–µ–Ω.</p>
            <div class="modal-stats">
                <p>–°—Ä–µ–¥–Ω–∏–π –±–∞–ª–ª: <strong id="modalAvg">5.0</strong></p>
                <p id="modalAdvice"></p>
            </div>
            <button class="btn btn-close" onclick="closeModal()">–ó–∞–∫—Ä—ã—Ç—å</button>
        </div>
    </div>

    <script>
        const categories = [
            { id: 'career', name: '–ö–∞—Ä—å–µ—Ä–∞', icon: 'üíº' },
            { id: 'finance', name: '–§–∏–Ω–∞–Ω—Å—ã', icon: 'üí∞' },
            { id: 'health', name: '–ó–¥–æ—Ä–æ–≤—å–µ', icon: '‚ù§Ô∏è' },
            { id: 'family', name: '–°–µ–º—å—è', icon: 'üë®‚Äçüë©‚Äçüëß‚Äçüë¶' },
            { id: 'friends', name: '–î—Ä—É–∑—å—è', icon: 'ü§ù' },
            { id: 'hobby', name: '–•–æ–±–±–∏', icon: 'üé®' },
            { id: 'growth', name: '–°–∞–º–æ-\n—Ä–∞–∑–≤–∏—Ç–∏–µ', icon: 'üìö' },
            { id: 'living', name: '–£—Å–ª–æ–≤–∏—è\n–∂–∏–∑–Ω–∏', icon: 'üè†' }
        ];

        const values = {};
        categories.forEach(cat => values[cat.id] = 5);

        const svg = document.getElementById('radarChart');
        const centerX = 300;
        const centerY = 300;
        const maxRadius = 180;
        const levels = 10;

        let isDragging = false;
        let dragIndex = -1;

        function getPoint(index, value) {
            const angle = (Math.PI * 2 / categories.length) * index - Math.PI / 2;
            const radius = (value / 10) * maxRadius;
            return {
                x: centerX + radius * Math.cos(angle),
                y: centerY + radius * Math.sin(angle)
            };
        }

        function getAngleForIndex(index) {
            return (Math.PI * 2 / categories.length) * index - Math.PI / 2;
        }

        function getValueFromPosition(x, y, index) {
            const angle = getAngleForIndex(index);
            
            const dx = x - centerX;
            const dy = y - centerY;
            
            const axisX = Math.cos(angle);
            const axisY = Math.sin(angle);
            
            const projection = dx * axisX + dy * axisY;
            
            let value = Math.round((projection / maxRadius) * 10);
            value = Math.max(1, Math.min(10, value));
            
            return value;
        }

        function drawChart() {
            svg.innerHTML = '';

            // Draw background grid circles
            for (let i = 1; i <= levels; i++) {
                const radius = (i / levels) * maxRadius;
                const points = [];
                for (let j = 0; j < categories.length; j++) {
                    const angle = (Math.PI * 2 / categories.length) * j - Math.PI / 2;
                    points.push(`${centerX + radius * Math.cos(angle)},${centerY + radius * Math.sin(angle)}`);
                }
                
                const polygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                polygon.setAttribute('points', points.join(' '));
                polygon.setAttribute('fill', i % 2 === 0 ? 'rgba(0, 59, 72, 0.03)' : 'transparent');
                polygon.setAttribute('stroke', '#d1d5db');
                polygon.setAttribute('stroke-width', i === 5 || i === 10 ? '2' : '1');
                polygon.setAttribute('stroke-dasharray', i === 5 ? '5,5' : 'none');
                svg.appendChild(polygon);
            }

            // Draw axis lines and scale numbers
            categories.forEach((cat, index) => {
                const angle = getAngleForIndex(index);
                
                // Axis line
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', centerX);
                line.setAttribute('y1', centerY);
                line.setAttribute('x2', centerX + maxRadius * Math.cos(angle));
                line.setAttribute('y2', centerY + maxRadius * Math.sin(angle));
                line.setAttribute('stroke', '#9ca3af');
                line.setAttribute('stroke-width', '1');
                svg.appendChild(line);

                // Draw scale number 5 on each axis
                const num5Radius = (5 / 10) * maxRadius;
                const num5X = centerX + num5Radius * Math.cos(angle);
                const num5Y = centerY + num5Radius * Math.sin(angle);
                
                const perpAngle = angle + Math.PI / 2;
                const offsetDist = 12;
                
                const text5 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text5.setAttribute('x', num5X + offsetDist * Math.cos(perpAngle));
                text5.setAttribute('y', num5Y + offsetDist * Math.sin(perpAngle));
                text5.setAttribute('text-anchor', 'middle');
                text5.setAttribute('dominant-baseline', 'middle');
                text5.setAttribute('fill', '#9ca3af');
                text5.setAttribute('font-size', '10');
                text5.setAttribute('font-weight', '600');
                text5.textContent = '5';
                svg.appendChild(text5);

                // Draw scale number 10 at each corner (outside the graph)
                const num10Radius = maxRadius + 15;
                const num10X = centerX + num10Radius * Math.cos(angle);
                const num10Y = centerY + num10Radius * Math.sin(angle);
                
                const text10 = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text10.setAttribute('x', num10X);
                text10.setAttribute('y', num10Y);
                text10.setAttribute('text-anchor', 'middle');
                text10.setAttribute('dominant-baseline', 'middle');
                text10.setAttribute('fill', '#9ca3af');
                text10.setAttribute('font-size', '11');
                text10.setAttribute('font-weight', '700');
                text10.textContent = '10';
                svg.appendChild(text10);
            });

            // Draw category labels with icons
            categories.forEach((cat, index) => {
                const angle = getAngleForIndex(index);
                const labelRadius = maxRadius + 55;
                const x = centerX + labelRadius * Math.cos(angle);
                const y = centerY + labelRadius * Math.sin(angle);
                
                // Determine text anchor based on position
                let anchor = 'middle';
                let textOffsetX = 0;
                
                if (Math.cos(angle) > 0.3) {
                    anchor = 'start';
                    textOffsetX = 8;
                } else if (Math.cos(angle) < -0.3) {
                    anchor = 'end';
                    textOffsetX = -8;
                }

                // Icon
                const iconText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                iconText.setAttribute('x', x + textOffsetX);
                iconText.setAttribute('y', y - 12);
                iconText.setAttribute('text-anchor', anchor);
                iconText.setAttribute('dominant-baseline', 'middle');
                iconText.setAttribute('font-size', '20');
                iconText.textContent = cat.icon;
                svg.appendChild(iconText);
                
                // Name with line breaks
                const nameText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                nameText.setAttribute('x', x + textOffsetX);
                nameText.setAttribute('y', y + 10);
                nameText.setAttribute('text-anchor', anchor);
                nameText.setAttribute('dominant-baseline', 'middle');
                nameText.setAttribute('fill', '#003B48');
                nameText.setAttribute('font-size', '12');
                nameText.setAttribute('font-weight', '600');

                const lines = cat.name.split('\n');
                lines.forEach((line, lineIndex) => {
                    const tspan = document.createElementNS('http://www.w3.org/2000/svg', 'tspan');
                    tspan.setAttribute('x', x + textOffsetX);
                    tspan.setAttribute('dy', lineIndex === 0 ? '0' : '1.2em');
                    tspan.textContent = line;
                    nameText.appendChild(tspan);
                });

                svg.appendChild(nameText);
            });

            // Draw data polygon
            const dataPoints = categories.map((cat, index) => {
                const point = getPoint(index, values[cat.id]);
                return `${point.x},${point.y}`;
            });

            const dataPolygon = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            dataPolygon.setAttribute('points', dataPoints.join(' '));
            dataPolygon.setAttribute('fill', 'rgba(195, 21, 50, 0.25)');
            dataPolygon.setAttribute('stroke', '#C31532');
            dataPolygon.setAttribute('stroke-width', '3');
            dataPolygon.setAttribute('stroke-linejoin', 'round');
            svg.appendChild(dataPolygon);

            // Draw interactive data points
            categories.forEach((cat, index) => {
                const point = getPoint(index, values[cat.id]);
                
                // Larger invisible hit area
                const hitArea = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                hitArea.setAttribute('cx', point.x);
                hitArea.setAttribute('cy', point.y);
                hitArea.setAttribute('r', '20');
                hitArea.setAttribute('fill', 'transparent');
                hitArea.setAttribute('cursor', 'grab');
                hitArea.dataset.index = index;
                hitArea.addEventListener('mousedown', startDrag);
                hitArea.addEventListener('touchstart', startDrag, { passive: false });
                svg.appendChild(hitArea);
                
                // Visible point
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', point.x);
                circle.setAttribute('cy', point.y);
                circle.setAttribute('r', '10');
                circle.setAttribute('fill', '#C31532');
                circle.setAttribute('stroke', '#fff');
                circle.setAttribute('stroke-width', '3');
                circle.setAttribute('class', 'data-point');
                circle.setAttribute('pointer-events', 'none');
                circle.id = `point-${index}`;
                svg.appendChild(circle);

                // Value label on point
                const valueLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                valueLabel.setAttribute('x', point.x);
                valueLabel.setAttribute('y', point.y + 1);
                valueLabel.setAttribute('text-anchor', 'middle');
                valueLabel.setAttribute('dominant-baseline', 'middle');
                valueLabel.setAttribute('fill', '#fff');
                valueLabel.setAttribute('font-size', '10');
                valueLabel.setAttribute('font-weight', '700');
                valueLabel.setAttribute('pointer-events', 'none');
                valueLabel.textContent = values[cat.id];
                svg.appendChild(valueLabel);
            });

            // Center circle
            const centerCircle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
            centerCircle.setAttribute('cx', centerX);
            centerCircle.setAttribute('cy', centerY);
            centerCircle.setAttribute('r', '5');
            centerCircle.setAttribute('fill', '#003B48');
            svg.appendChild(centerCircle);

            updateAverageScore();
        }

        function startDrag(e) {
            e.preventDefault();
            isDragging = true;
            dragIndex = parseInt(e.target.dataset.index);
            
            document.getElementById(`point-${dragIndex}`).classList.add('dragging');
            
            document.addEventListener('mousemove', doDrag);
            document.addEventListener('mouseup', endDrag);
            document.addEventListener('touchmove', doDrag, { passive: false });
            document.addEventListener('touchend', endDrag);
        }

        function doDrag(e) {
            if (!isDragging) return;
            e.preventDefault();
            
            const rect = svg.getBoundingClientRect();
            const scaleX = 600 / rect.width;
            const scaleY = 600 / rect.height;
            
            let clientX, clientY;
            if (e.touches) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }
            
            const x = (clientX - rect.left) * scaleX;
            const y = (clientY - rect.top) * scaleY;
            
            const newValue = getValueFromPosition(x, y, dragIndex);
            const catId = categories[dragIndex].id;
            
            if (values[catId] !== newValue) {
                values[catId] = newValue;
                drawChart();
                document.getElementById(`point-${dragIndex}`).classList.add('dragging');
            }
        }

        function endDrag() {
            if (dragIndex >= 0) {
                const point = document.getElementById(`point-${dragIndex}`);
                if (point) point.classList.remove('dragging');
            }
            isDragging = false;
            dragIndex = -1;
            
            document.removeEventListener('mousemove', doDrag);
            document.removeEventListener('mouseup', endDrag);
            document.removeEventListener('touchmove', doDrag);
            document.removeEventListener('touchend', endDrag);
        }

        function downloadChartAsPng() {
            const svgNode = document.getElementById('radarChart');
            if (!svgNode) return;
            
            const scale = 2;
            const width = 600;
            const height = 600;

            // Clone SVG and prepare for export
            const clonedSvg = svgNode.cloneNode(true);
            clonedSvg.setAttribute('width', width);
            clonedSvg.setAttribute('height', height);
            clonedSvg.setAttribute('xmlns', 'http://www.w3.org/2000/svg');
            
            // Add background rect
            const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            bgRect.setAttribute('width', '100%');
            bgRect.setAttribute('height', '100%');
            bgRect.setAttribute('fill', '#ffffff');
            clonedSvg.insertBefore(bgRect, clonedSvg.firstChild);

            const serializer = new XMLSerializer();
            const svgString = serializer.serializeToString(clonedSvg);
            const svgBlob = new Blob([svgString], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);

            const img = new Image();
            img.onload = () => {
                const canvas = document.createElement('canvas');
                canvas.width = width * scale;
                canvas.height = height * scale;
                const ctx = canvas.getContext('2d');
                
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                ctx.scale(scale, scale);
                ctx.drawImage(img, 0, 0, width, height);

                URL.revokeObjectURL(url);

                canvas.toBlob((blob) => {
                    const link = document.createElement('a');
                    link.download = `wheel-of-life-${new Date().toISOString().slice(0, 10)}.png`;
                    link.href = URL.createObjectURL(blob);
                    link.click();
                    URL.revokeObjectURL(link.href);
                }, 'image/png');
            };
            img.src = url;
        }

        function updateAverageScore() {
            const sum = Object.values(values).reduce((a, b) => a + b, 0);
            const avg = (sum / categories.length).toFixed(1);
            document.getElementById('avgScore').textContent = avg;
        }

        function resetAll() {
            categories.forEach(cat => {
                values[cat.id] = 5;
            });
            drawChart();
        }

        function saveResult() {
            const sum = Object.values(values).reduce((a, b) => a + b, 0);
            const avg = (sum / categories.length).toFixed(1);
            
            document.getElementById('modalAvg').textContent = avg;
            
            let minVal = 11, maxVal = 0;
            let minCat = '', maxCat = '';
            
            categories.forEach(cat => {
                if (values[cat.id] < minVal) {
                    minVal = values[cat.id];
                    minCat = cat.name.replace('\n', '');
                }
                if (values[cat.id] > maxVal) {
                    maxVal = values[cat.id];
                    maxCat = cat.name.replace('\n', '');
                }
            });

            let advice = '';
            if (avg < 4) {
                advice = '‚ö†Ô∏è –û–±—Ä–∞—Ç–∏—Ç–µ –≤–Ω–∏–º–∞–Ω–∏–µ –Ω–∞ –æ–±—â–∏–π –±–∞–ª–∞–Ω—Å –∂–∏–∑–Ω–∏.';
            } else if (avg < 7) {
                advice = `üí° –°–∏–ª—å–Ω–∞—è —Å—Ç–æ—Ä–æ–Ω–∞: ${maxCat}. –°—Ç–æ–∏—Ç —Ä–∞–∑–≤–∏—Ç—å: ${minCat}.`;
            } else {
                advice = 'üåü –û—Ç–ª–∏—á–Ω—ã–π –∂–∏–∑–Ω–µ–Ω–Ω—ã–π –±–∞–ª–∞–Ω—Å! –ü—Ä–æ–¥–æ–ª–∂–∞–π—Ç–µ –≤ —Ç–æ–º –∂–µ –¥—É—Ö–µ!';
            }
            
            document.getElementById('modalAdvice').textContent = advice;
            document.getElementById('modalOverlay').classList.add('active');

            const saveData = {
                date: new Date().toISOString(),
                values: { ...values },
                average: avg
            };
            localStorage.setItem('wheelOfLife', JSON.stringify(saveData));

            // Download chart as PNG
            downloadChartAsPng();
        }

        function closeModal() {
            document.getElementById('modalOverlay').classList.remove('active');
        }

        document.getElementById('modalOverlay').addEventListener('click', (e) => {
            if (e.target === e.currentTarget) {
                closeModal();
            }
        });

        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape') {
                closeModal();
            }
        });

        function loadSavedData() {
            const saved = localStorage.getItem('wheelOfLife');
            if (saved) {
                try {
                    const data = JSON.parse(saved);
                    Object.keys(data.values).forEach(id => {
                        if (values.hasOwnProperty(id)) {
                            values[id] = data.values[id];
                        }
                    });
                } catch (e) {
                    console.log('No saved data to load');
                }
            }
        }

        // Initialize
        loadSavedData();
        drawChart();
    </script>
</body>
</html>
